#!/bin/bash

# llvm_patch.sh must be in the working directory
# if [[ ! (-e 'llvm_patch.sh') ]]; then
    # echo "file llvm_patch.sh (from pandora-eval repo root) must be in the working directory"
    # exit 1
# fi

CIOCC_LOCATION=$(realpath ~/tmp/pandora-eval)

if [[ ! (-e "$CIOCC_LOCATION/llvm_patch.sh") ]]; then
    echo "file llvm_patch.sh (from pandora-eval repo root) must be in the working directory"
    exit 1
fi

source "$CIOCC_LOCATION/llvm_patch.sh" # imports function inline_patch_mir_file

TOOLNAME=ciocc
INIT_ARGS="$@"

LINK_MODE=0
SEEN_C_FLAG=0
SEEN_O_FLAG=0
OPT_FLAG="" # llc defaults to O2

C_FILE=""
OBJ_FILE=""
ASM_FILE=""
LL_FILE=""
MIR_FILE=""
LIBTOOL_OBJ_FILE=""

echo "[*] ciocc init args: $INIT_ARGS"

# for saving state about this object file's compilation for later cio use.
# cio calls make which calls libtool which calls ciocc.
# a lot of cio's work runs on intermediate libtool build artifacts.
# ciocc knows about these build artifacts, but cio does not.
# so save some of this info in a bash script denoted by $CIOCC_FILE
# that cio can source--i.e., 'source $CIOCC_FILE' where
# CIOCC_FILE is the mir file name for this object file
# with the .mir suffix changed to .ciocc--i.e., source ${SOME_MIR_FILE/%.mir/.ciocc}
# gives cio the needed information for this .mir/.o/.ll file.
CIOCC_FILE="" 

COMPILER_DIR="/home/mkf/llvm-project/build/bin/"
COMPILER="$COMPILER_DIR/clang"
LLC="$COMPILER_DIR/llc"
LLVM_MC="$COMPILER_DIR/llvm-mc"

LLC_FLAGS="--relocation-model=pic"
LLVM_MC_FLAGS="--position-independent"

FINAL_ARGS=()

while [[ $# -gt 0 ]]; do
    if [[ ! ("$1" =~ 'PACKAGE_STRING') && "$1" != "-g" ]]; then
	FINAL_ARGS+=( "$1" )
    fi
    
    case "$1" in
	'-fPIC')
	    # LLC_FLAGS="--relocation-model=pic"
	    # LLVM_MC_FLAGS="--position-independent"
	    shift
	    continue
	    ;;
	'-o')
	    SEEN_O_FLAG=1
	    if [[ "$2" =~ \.la$ ]]; then
		LINK_MODE=1
	    fi
	    OBJ_FILE="$2"
	    LL_FILE=${OBJ_FILE/%.o/.ll}
	    LL_FILE=${LL_FILE/%.lo/.ll}
	    LIBTOOL_OBJ_FILE=${LL_FILE/%.ll/.lo}
	    MIR_FILE=${OBJ_FILE/%.o/.mir}
	    MIR_FILE=${MIR_FILE/%.lo/.mir}
	    INDEXED_MIR_FILE=${OBJ_FILE/%.o/.indexed.mir}
	    INDEXED_MIR_FILE=${INDEXED_MIR_FILE/%.lo/.indexed.mir}
	    ASM_FILE=${OBJ_FILE/%.o/.s}
	    ASM_FILE=${ASM_FILE/%.lo/.s}
	    CIOCC_FILE=${MIR_FILE/%.mir/.ciocc}

	    # libtool/autotools used?
	    LL_FILE=${LL_FILE/.libs/}
	    LIBTOOL_OBJ_FILE=${LIBTOOL_OBJ_FILE/.libs/}
	    MIR_FILE=${MIR_FILE/.libs/}
	    ASM_FILE=${ASM_FILE/.libs/}
	    CIOCC_FILE=${CIOCC_FILE/.libs/}
	    
	    # if [[ "$OBJ_FILE" =~ '\.libs' ]]; then
	    # 	echo "has .libs"
	    # 	LL_FILE=${LL_FILE/.libs/}
	    # 	MIR_FILE=${MIR_FILE/.libs/}
	    # 	ASM_FILE=${ASM_FILE/.libs/}
	    # else
	    # 	echo "doesn't have .libs"
	    # fi
	    FINAL_ARGS+=( "$LL_FILE" )
	    shift 2
	    continue
	    ;;
	'-c')
	    if [[ "$2" =~ \.(c|cpp)$ ]]; then
		SEEN_C_FLAG=1
		C_FILE="$2"
		FINAL_ARGS+=( "$2" )
		shift 2
	    else
		shift
	    fi
	    continue
	    ;;
	'-O0' | '-O1' | '-O2' | '-O3' | '-Ofast')
	    OPT_FLAG=$1
	    FINAL_ARGS+=( "-emit-llvm" )
	    shift
	    continue
	    ;;
	*)
	    shift
	    continue
	    ;;
    esac
    shift
done

# if '$(CC) ... -c foo.c -o foo.o ...' command, then
# run things through '.c -> .ll -> .mir -> .o' pipeline (or comparable)
if [[ $SEEN_C_FLAG -eq 1 && $SEEN_O_FLAG -eq 1 && $LINK_MODE -ne 1 ]]; then
    if [[ -z "$LL_FILE" || -z "$OBJ_FILE" || -z "$MIR_FILE" ]]; then
	echo "Error getting .ll/.mir file name for command: $@, OBJ_FILE=$OBJ_FILE"
	exit 1
    fi
    
    # Make doesn't properly handle our intermediate build artifacts
    # Build them clean from scratch every time
    test -e "$LL_FILE" && rm "$LL_FILE"
    test -e "$MIR_FILE" && rm "$MIR_FILE"
    test -e "$ASM_FILE" && rm "$ASM_FILE"
    test -e "$INDEXED_MIR_FILE" && rm "$INDEXED_MIR_FILE"

    set -x

    $COMPILER "${FINAL_ARGS[@]}"

    # --debug-pass=Structure
    $LLC "$LLC_FLAGS" --stop-after=pseudo-probe-inserter $OPT_FLAG $LL_FILE -o $MIR_FILE

    TO_MIR_RET=$?
    
    if [[ "$TO_MIR_RET" -ne 0 ]]; then
	echo "Converting .ll to .mir call failed with exit status $TO_MIR_RET: $LL_FILE -> $MIR_FILE"
	exit $TO_MIR_RET
    fi

    # fixups for invalid MIR serialized by LLVM
    inline_patch_mir_file "$MIR_FILE"

    # -x86-cs -x86-gen-idx
    # --run-pass=ss,csimp-mitigation
    $LLC --disable-verify \
	 -x=mir \
	 --run-pass=ss \
	 --x86-ss --x86-gen-idx \
	 "$MIR_FILE" -o "$INDEXED_MIR_FILE"

    ADD_INSN_INDICES_PASS_RET=$?

    if [[ "$ADD_INSN_INDICES_PASS_RET" -ne 0 ]]; then
	echo "Non-zero exit status running pass to add insn indices in ciocc: $ADD_INSN_INDICES_PASS_RET"
	exit $ADD_INSN_INDICES_PASS_RET
    fi

    inline_patch_mir_file "$INDEXED_MIR_FILE"

    # --debug-pass=Structure 
    $LLC "$LLC_FLAGS" --disable-verify --filetype=asm --start-after=pseudo-probe-inserter $OPT_FLAG $INDEXED_MIR_FILE -o $ASM_FILE

    # $LLC "$LLC_FLAGS" --simplify-mir --debug-pass=Structure --filetype=obj "$OPT_FLAG" "$LL_FILE" -o "$OBJ_FILE"
    
    TO_ASM_RET=$?
    
    if [[ "$TO_ASM_RET" -ne 0 ]]; then
	echo ".mir to .s call failed with exit status $TO_ASM_RET: $INDEXED_MIR_FILE -> $ASM_FILE"
	exit $TO_ASM_RET
    fi

    $LLVM_MC "$LLVM_MC_FLAGS" $ASM_FILE --filetype=obj -o $OBJ_FILE

    TO_OBJ_RET=$?

    if [[ "$TO_OBJ_RET" -ne 0 ]]; then
	echo ".s to .o call failed with exit status $TO_OBJ_RET: $ASM_FILE -> $OBJ_FILE"
	exit $TO_OBJ_RET
    fi

    # save state for cio to use later
    echo "OBJ_FILE=$(realpath $OBJ_FILE)" > "$CIOCC_FILE"
    echo "MIR_FILE=$(realpath $MIR_FILE)" >> "$CIOCC_FILE"
    echo "ASM_FILE=$(realpath $ASM_FILE)" >> "$CIOCC_FILE"
    echo "INDEXED_MIR_FILE=$(realpath $INDEXED_MIR_FILE)" >> "$CIOCC_FILE"
    echo "LIBTOOL_OBJ_FILE=$(realpath $LIBTOOL_OBJ_FILE)" >> "$CIOCC_FILE"
else
    # then probably linking or assembling, just pass the arguments through
    echo "LINKING OR ASSEMBLING: $COMPILER $@"
    $COMPILER "$@"
fi

exit 0
